#!/bin/bash
function contextSwitch {
	{
	ctxt1=$(grep ctxt /proc/stat | awk '{print $2}')
        echo 50
	sleep 1
        ctxt2=$(grep ctxt /proc/stat | awk '{print $2}')
        ctxt=$(($ctxt2 - $ctxt1))
        result="Number os context switches in the last secound: $ctxt"
	echo $result > result
	} | whiptail --gauge "Getting data ..." 300 300 20
}

# 0 - это высота | 0 это ширина | 20 это 
while [ 1 ]
do
CHOICE=$(
whiptail --title "Редактирование настроечного файла Bashrc" --menu "\
Клавишами верх/низ выберите справку и нажмите enter. Для выхода выберите End script" 0 0 20\
	"1)" "Отредактировать файл bashrc вариант ne"\
	"2)" "Отредактировать файл bashrc вариант echo"\
	"3)" "Перезагрузить файл bashrc"\
	"4)" "Мои alias"\
	"5)" "Вывести все определённые псевдонимы"\
        "6)" "Скрыть username@localhost в терминале"\
        "7)" "Изменить username@localhost в терминале"\
        "8)" "Индикатор прогресса копирования файла"\
        "9)" "Индикатор прогресса при создании архива"\
       "10)" "Раскраска команд консоли"\
       "11)" "Мои alias grc"\
       "12)" "Таблица цветов bash"\
       "13)" "Раскраска username@localhost"\
       "14)" "Автораскраска"\
       "15)" "End script"  3>&2 2>&1 1>&3	
)

result=$(whoami)
case $CHOICE in
	"1)")   
		result="ne ~/.bashrc"
	;;
	"2)")   
	        result="echo -e \"текст\" >> ~/.bashrc"
	;;

	"3)")   
	        result="source ~/.bashrc"
        ;;

	"4)")   
result="\n
 alias ca='cd ; clear'\n
 alias cb='cd ; clear ; ls -l'\n
      cc команда компиляции\n
      cd команда перехода в каталог\n
 alias ce='cd .. ; clear ; ls -l'\n
 alias cf='clear ; ls -l'\n
      cg команда зарезервирована\n   
 alias ch='clear ; ls -l ; pwd'\n
 alias cr='cd ; scrot -s'\n
И не забывать конспектировать все команды и проверять их на незарезервированость !!!\n
cr команда не найдена - это значит можно создавать alias"
        ;;

"6)")   
result="PS1=\"\\W>\""
;;

"7)")   
result="Добавьте следующую строку в конце:\n
PS1=\"Любое имя\""
;;

"8)")
result="\
rsync, который хоть и несколько замедляет процесс копирования, но зато обеспечивает вывод на экран шкалы прогресса.\n
Помещаем в ~/.bashrc следующую строку:\n
alias cpr='rsync --progress'\n
И используем команду cpr вместо cp: $ cpr file1 file2\n
Если добавить опцию '--remove-source-files', то исходные файлы будут удалены (правда, следует помнить,\n
что в пределах одной файловой системы mv гораздо быстрее rsync).\n
Единственный минус — прогресс отображается для каждого файла в отдельности, общий прогресс увидеть нельзя."
;;
        
"9)")
result="\
Чтобы увидеть ход выполнения, например, при создании архива, можно использовать утилиту pv (Pipe Viewer).\n
Технически она представляет собой замену стандартного cat, способную не только тупо копировать байты на выход,\n
но и показывать прогресс этой операции. Например:\n
$ tar -czf — /path/to/dir | pv > /path/to/archive.tgz\n
758MB 0:01:29 [8,48MB/s] [ <=>\n
Уже хорошо. Но не хватает времени завершения. Для этого надо передать утилите pv размер каталога (в байтах) с помощью ключа '-s':\n
$ tar -czf — /path/to/dir | pv -s $(du -sb /path/to/dir | grep -o '[0-9]*') > /path/to/archive.tgz\n
461MB 0:00:21 [ 32MB/s] [=======================================> ] 60% ETA 0:00:13
Каждый раз набирать такую конструкцию не очень удобно, лучше сделать алиас."
;;

"10)")
result="\
Для того, чтобы раскрашивать вывод команд в консоли (подсвечивать результат), можно воспользоваться утилитой Generic Colouriser (grc).\n
Для установки утилиты (в Ubuntu) выполните в командной строке:\n
sudo apt-get install grc\n
Данная утилита использует файлы конфигурации, в которых прописаны регулярные выражения (Regular Expression), содержащие правила раскрашивания.\n
Вместе с утилитой устанавливаются несколько файлов конфигурации для некоторых Linux команд (располагаются в директории /usr/share/grc).\n
Информацию по составлению своих собственных файлов вы можете прочитать в README файле.\n
Теперь нам нужно прописать алиасы тем командам, вывод которых мы хотим раскрашивать.\n
Фактически для этих команд мы будем вызывать утилиту grc с указанием того, какую команду нам нужно раскрасить.\n
Откроем файл Bashrcи в конец файла добавим следующие строки:\n
\n
if\n
[ -f /usr/bin/grc ]; then\n
  alias название команды=\"grc --colour=auto название команды\"\n
fi"
;;

"11)")
result="if [ -f /usr/bin/grc ]; then\n
  alias cvs=\"grc --colour=auto cvs\"\n
  alias diff=\"grc --colour=auto diff\"\n
  alias esperanto=\"grc --colour=auto esperanto\"\n
  alias gcc=\"grc --colour=auto gcc\"\n
  alias irclog=\"grc --colour=auto irclog\"\n
  alias ldap=\"grc --colour=auto ldap\"\n
  alias log=\"grc --colour=auto log\"\n
  alias netstat=\"grc --colour=auto netstat\"\n
  alias ping=\"grc --colour=auto ping\"\n
  alias proftpd=\"grc --colour=auto proftpd\"\n
  alias traceroute=\"grc --colour=auto traceroute\"\n
  alias wdiff=\"grc --colour=auto wdiff\"\n
fi"
;;

"12)") result="
А с помощью этой таблици вы можете подобрать цвет, который вам по душе.
‘\e[0;30m’ # Black  ‘\e[1;30m’ # Black 	‘\e[4;30m’ # Black  ‘\e[40m’ # Black\n
‘\e[0;31m’ # Red    ‘\e[1;31m’ # Red 	‘\e[4;31m’ # Red    ‘\e[41m’ # Red\n
‘\e[0;32m’ # Green  ‘\e[1;32m’ # Green 	‘\e[4;32m’ # Green  ‘\e[42m’ # Green\n
‘\e[0;33m’ # Yellow ‘\e[1;33m’ # Yellow ‘\e[4;33m’ # Yellow ‘\e[43m’ # Yellow\n
‘\e[0;34m’ # Blue   ‘\e[1;34m’ # Blue 	‘\e[4;34m’ # Blue   ‘\e[44m’ # Blue\n
‘\e[0;35m’ # Purple ‘\e[1;35m’ # Purple ‘\e[4;35m’ # Purple ‘\e[45m’ # Purple\n
‘\e[0;36m’ # Cyan   ‘\e[1;36m’ # Cyan 	‘\e[4;36m’ # Cyan   ‘\e[46m’ # Cyan\n
‘\e[0;37m’ # White  ‘\e[1;37m’ # White  ‘\e[4;37m’ # White  ‘\e[47m’ # White"
;;

"13)") result="
В этой строке указаны все наши цвета для имени пользователя, имени хоста и др.\n
PS1='\[\e[1;33m\]\u\[\e[1;35m\]@\[\033[1;32m\]\h \[\e[1;34m\]\w\[\e[m\] \[\e[1;32m\]\$\[\e[m\] \[\e[1;37m\]'\n
Из чего состоит эта строка.\n
PS1=’\[\e[1;33m\]\u – этот кусочек строки означает что мы присваиваем имени нашего пользователя желтый жирный цвет.\n
\[\e[1;35m\]@ – далее идет символ собачки с фиолетовым жирным цветом\n
\[\033[1;32m\]\h – имя компьютера в сети жирного зеленого цвета\n
\[\e[1;34m\]\w – текущая директория – жирным голубым цветом\n
\[\e[1;32m\]\$ – знак доллара раскрашен жирным зеленым цветом\n
\[\e[1;37m\]’ – и последний белый цвет который обозначает то что мы будем вводить в терминале.\n
Через точку с запятой можно указать цвет фона. Для этой цели используются числа от 40 черный до 47 белый. PS1=\"[�33[32;40mw[�33[0m]>\"\n
Для того чтобы изменить цвет строк, когда вы используете root-права, откройте этот же файл только с root-правами\n
И тоже вставьте в конец файла вот такой кусок кода\n
PS1='\[\e[1;31m\]\u\[\e[m\] \[\e[1;34m\]\w\[\e[m\] \[\e[1;31m\]\$ \[\e[m\]\[\e[1;32m\]'\n
Который перекрасит приглашение root в красный цвет, текущую директорию в синий, а цвет ввода текста в зеленый цвет."
;;

"14)") result="
Некоторые команды поддерживают цветной вывод. Проще это решить при помощи алиасов:\
alias ls='ls --color=auto'\n
alias grep='grep --color=auto'\n
И так далее.\n
За настройки цветов каталогов и файлов с разным расширением отвечает утилита dircolors.\n
Устанавливающая переменную LC_COLORS. Чтобы получить все значения, просто вводим:\n
 dircolors --print-database\n
Использовав полученный результат как шаблон и сохранив его в / etc/DIR_COLORS (либо в персональном конфиге ~/.dir_colors),\n
можно создать свою раскраску."
;;

"15)") exit
;;

esac
whiptail --msgbox "$result" 0 0
done
exit